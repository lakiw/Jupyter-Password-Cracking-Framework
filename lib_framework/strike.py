"""
Classes to represent sucessfull cracks against hashes

Attack/Crack were the two leading contenders on what to call this class, but after
thinking about it I personally like the term "Strike" since it implies a sucessful
attack.

Most of the details about a Strike are going to be password cracking tool specific.
Aka the attack mode used, the flags for that attack, etc. Therefore I'm going to put those
details into a "details" dictionary and let the PWCrackerMgr handle what to do with them.

StrikeList will handle metadata for adding strikes (and detecting duplicates) as well
as managing various lookup tables

"""


class Strike:
    """
    Information about a particular sucessfull attack

    Much of this info will be password cracking tool specific so I'll let the tool set that info
    and parse it

    """

    def __init__(self, pw_cracker_mgr, hash_id, details = {}):
        """
        Initializes the Strike

        Inputs:
            pw_cracker_mgr: (PWCrackerMgr) The PWCrackerMgr object that this session was created with
            I'm doing this so I don't need to remember what string I used to represent
            John the Ripper vs. Hashcat

            hash_id: (Int) The id of the hash cracked by this attack

            details: (Dict) Details about the specific crack. The format is password cracker specific
            so this datastructure doesn't dig into it
        """
        self.tool = pw_cracker_mgr.name
        self.hash_id = hash_id

        # Want to create a copy so it doesn't get accidently changed when updating multiple strikes
        self.details = details.copy()


class StrikeList:
    """
    Keeps track of all the strikes
    """

    def __init__(self):
        """
        Pretty boring, just initializes all the datastructures
        """

        # Holds all the strikes
        # The key is the index that other related datastructures will
        # reference (vs. referencing the raw strikes)
        self.strikes = {}

        # Keeps track of the next index number to assign for the strikes
        self.next_index = 0

        # Key = hash_id, value = (List) indexes of strikes for that hash_id
        # Used to find all the strikes for a particular hash. If the hash
        # hasn't been cracked, it will not exist in this list. Note, there
        # is also a "None" lookup for strikes that are not associated with a
        # specific hash. This can occur from JtR log files which won't record
        # the cracked hash by default
        self.hash_id_lookup = {}

        # Key = PWCrackerMgr Name, value = (List) indexes of strikes that have been
        # generated by this tool
        # Used to generate a list of all strikes/rules for a particular tool
        self.tool_lookup = {}

    def add(self, pw_cracker_mgr, hash_id, details):
        """
        Inputs:
            pw_cracker_mgr: (PWCrackerMgr) The PWCrackerMgr object that this session was created with
            I'm doing this so I don't need to remember what string I used to represent
            John the Ripper vs. Hashcat

            hash_id: (Int) The id of the hash cracked by this attack

            details: (Dict) Details about the specific crack. The format is password cracker specific
            so this datastructure doesn't dig into it

        Returns:
            strike_id: (INT) The ID of the Strike. If a problem occurs, returns -1
        """
        # Check to make sure this isn't a duplicate
        # hash_id_lookup is a quick way to narrow things down
        if hash_id in self.hash_id_lookup:
            strikes = self.hash_id_lookup[hash_id]
            for strike_id in strikes:
                if self.strikes[strike_id].tool == pw_cracker_mgr.name:
                    exact_match = True
                    for key, value in details.items():
                        if key in self.strikes[strike_id].details and value == self.strikes[strike_id].details[key]:
                            pass
                        else:
                           exact_match = False
                           break
                    if exact_match:
                        return strike_id

        # Add the strike
        strike_id = self.next_index
        self.next_index += 1

        self.strikes[strike_id] = Strike(pw_cracker_mgr, hash_id, details)

        # Update the lookup datastructures
        if hash_id not in self.hash_id_lookup:
            self.hash_id_lookup[hash_id] = []
        self.hash_id_lookup[hash_id].append(strike_id)

        if pw_cracker_mgr.name not in self.tool_lookup:
            self.tool_lookup[pw_cracker_mgr.name] = []
        self.tool_lookup[pw_cracker_mgr.name].append(strike_id)

        return strike_id