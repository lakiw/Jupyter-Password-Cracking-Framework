"""
Python Mixin extension to the SessionMgr class to hold functions related to performing
analysis on Strikes. Aka creating lists of all the rules that cracked a group of passwords

Since this is a Mixin instance, it is not stand alone code.
The goal is to reduce the size of the main SessionMgr file

"""


import os
from collections import Counter


class Mixin:
        
    def create_ruleset_from_cracked_hashes(self, file_name=None, hash_type=None, filter=None, warnings=False):
        """
        Creates a set of password cracking rules based on Strikes (rules that cracked passwords)
        ONLY looks at strikes that have been matched to hashes loaded into the framework

        Dev Note: Currently not doing any fixup between hashcat and jtr style rule formats

        Inputs:

            file_name: (String) If it is not None, write the ruleset to this filename

            hash_type: (String) If not none, only use cracked passwords of hashes of this type
            to generate the ruleset. If None, then it will use all cracked passwords regardless of type

            filter: (Dict) All key/value pairs must match metadata for cracked passwords to
            be used to generate the ruleset. If None the filter is ignored. If a value is None, then
            it will use all passwords that have a metadata with the particular key set.

            warnings: (Bool) If True, print warnings to stdout if this is run and there are no valid
            strikes to create a ruleset from

        Returns:
            ruleset_counter: (Counter) Counter object of all the rules generated by this function
        """

        # Create the list of strikes to base the rule generation off of
        strikes = self.get_strikes_based_on_filter(hash_type=hash_type, filter=filter)
        
        # Using a counter to order the results with the most effective rules first
        ruleset_counter = Counter()

        # Go through all the strikes, remove duplicate rules, and arrange rules in
        # order of effectiveness
        for strike_id in strikes:
            if self.strike_list.strikes[strike_id].details['attack'] == "wordlist":
                # Handle the "None" rule from things like input from stdin
                if not self.strike_list.strikes[strike_id].details['rule']:
                    ruleset_counter[":"] += 1
                else:
                    ruleset_counter[self.strike_list.strikes[strike_id].details['rule']] += 1

        if not ruleset_counter:
            if warnings:
                print("Warning: No strikes were found that matched the filter criteria, so no rules were generated")
            return ruleset_counter
        
        # If not printing to stdout, open the file 
        if file_name:
            try:
                file = open(file_name, mode='w')
                for rule in ruleset_counter.most_common():
                    file.write(f"{rule[0]}\n")
                file.close()

            except Exception as msg:
                print(f"Exception writing to {file_name}: {msg}")
                return

        return ruleset_counter
    
    def create_ruleset_from_uncategorized_cracks(self, file_name=None, warnings=True):
        """
        Creates a set of password cracking rules based on Strikes (rules that cracked passwords)
        ONLY looks at strikes that have not been matched to hashes loaded into the framework

        Dev Note: Currently not doing any fixup between hashcat and jtr style rule formats

        Inputs:

            file_name: (String) If it is not None, write the ruleset to this filename

            warnings: (Bool) If True, print warnings to stdout if this is run and there are no valid
            strikes to create a ruleset from

        Returns:
            ruleset_counter: (Counter) Counter object of all the rules generated by this function
        """

        # Using a counter to order the results with the most effective rules first
        ruleset_counter = Counter()

        # Create the list of strikes to base the rule generation off
        if None not in self.strike_list.hash_id_lookup:
            if warnings:
                print(f"No uncategorized strikes (aka not matched up to hashes in this framework) found")
            return ruleset_counter
        
        strikes = self.strike_list.hash_id_lookup[None]

        # Go through all the strikes, remove duplicate rules, and arrange rules in
        # order of effectiveness
        for strike_id in strikes:
            if self.strike_list.strikes[strike_id].details['attack'] == "wordlist":
                # Handle the "None" rule from things like input from stdin
                if not self.strike_list.strikes[strike_id].details['rule']:
                    ruleset_counter[":"] += 1
                else:
                    ruleset_counter[self.strike_list.strikes[strike_id].details['rule']] += 1

        # If not printing to stdout, open the file 
        if file_name:
            try:
                file = open(file_name, mode='w')
                for rule in ruleset_counter.most_common():
                    file.write(f"{rule[0]}\n")
                file.close()

            except Exception as msg:
                print(f"Exception writing to {file_name}: {msg}")
                return

        return ruleset_counter

    def get_strikes_based_on_filter(self, hash_type=None, filter=None):
        """
        Returns a set of all strikes that match a filter

        Inputs:

            hash_type: (String) If not none, only use cracked passwords of hashes of this type
            to generate the ruleset. If None, then it will use all cracked passwords regardless of type

            filter: (Dict) All key/value pairs must match metadata for cracked passwords to
            be used to generate the ruleset. If None the filter is ignored. If a value is None, then
            it will use all passwords that have a metadata with the particular key set.

        Returns:
            strikes: (List) List of all the strikes that match the filter
        """

        strikes = []

        # Go through all the hash_ids that have strikes associated with them
        for hash_id in self.strike_list.hash_id_lookup.keys():

            # Filter based on hash_type if specified
            if hash_type:
                if hash_id not in self.hash_list.type_lookup or self.hash_list.type_lookup[hash_id] != hash_type:
                    continue

            # Next filter based on filters/metadata
            if not self._filter_hash_id(hash_id=hash_id, hash_type=hash_type, filter=filter):
                 continue

            # Match successful. Add all strikes associated with the hash_id
            for strike_id in self.strike_list.hash_id_lookup[hash_id]:
                if strike_id not in strikes:
                    strikes.append(strike_id)

        return strikes