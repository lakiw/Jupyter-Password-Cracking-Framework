"""
Classes to represent individual cracking sessions/runs

This will fill multiple roles/uses so expect a lot of change and tunes
to this class as it gets more use.

Session represents the actual run itself

SessionList keeps track of multiple sessions as well as maintains various
quick lookup lists

"""


class Session:
    """
    Information about a particular cracking session

    Includes details about the attack that was run, if the session was compleated,
    and what hashes were cracked during the session
    """

    def __init__(self, pw_cracker_mgr, session_info, compleated=False):
        """
        Initializes the session, don't include specific cracks yet

        Inputs:
            pw_cracker_mgr: (PWCrackerMgr) The PWCrackerMgr object that this session was created with
            I'm doing this so I don't need to remember what string I used to represent
            John the Ripper vs. Hashcat

            session_info: (Dict) This is generated by pw_cracker_mgr to contain information about the
            particular attack. They will probably be mostly the same, but I'd like to add flexability
            when adding new password crackign tools

            compleated: (Bool) If this session was finalized/completed or if it was only partially
            run.
        """
        self.tool = pw_cracker_mgr.name

        # There are five top level modes for attacks. There can be overlaps
        # aka mask + wordlist. In that case the following order is enforced
        #
        # single = JtR Single mode. This includes incremental + basic wordlist based on hash data
        # wordlist = there is an input dictionary. This can include attacks like PRINCE
        # mask = There is a mask used to generat the password
        # brute = This can include markov and incremental attacks
        # stdin = The guesses were generated by an external source
        self.mode = None
        if 'mode' in session_info:
            self.mode = session_info['mode']

        self.compleated = compleated

        # Session specific options
        self.options = {}
        if 'options' in session_info:
            self.options = session_info['options']

        # Add the hash type that was targetd
        self.hash_type = None
        if 'hash_type' in session_info:
            self.hash_type = session_info['hash_type']

        # How many hashes were loaded in the attack
        self.num_loaded_hashes = None
        if 'num_loaded_hashes' in session_info:
            self.num_loaded_hashes = session_info['num_loaded_hashes']

        # The specific hashes that we know were included in this attack
        # Can be added to later if desired
        self.hashes = []

        # How many hashes were cracked in the attack
        self.num_cracked_hashes = 0

        # Just contains the indexes to the specific strikes
        # Doing this way since most times I expect users will want to look
        # at the cracks/rules/successful_attacks and won't want to go through
        # the session to find it.
        self.strike_id_list = []

    def add_strike(self, strike_id):
        """
        Adds a strike by id to this session

        Just doing the strike_id since I don't see a reason to add additional
        info into this datastructure
        
        Inputs:
            strike_id: (Int) The id to the crack/successful rule
        
        Returns:
            num_new: (Int) the number of new cracks from this crack. Will be 0 or 1.
        """
        if strike_id in self.strike_id_list:
            return 0
        self.strike_id_list.append(strike_id)
        self.num_cracked_hashes += 1
        return 1
    
    def add_hash(self, hash_id):
        """
        Adds a hash by id to this session

        Just doing the hash_id since I don't see a reason to add additional
        info into this datastructure
        
        Inputs:
            hash_id: (Int) The id to the hash
        
        Returns:
            num_new: (Int) the number of new hashes. Will be 0 or 1.
        """
        if hash_id in self.hashes:
            return 0
        self.hashes.append(hash_id)
        return 
    

class SessionList:
    """
    Keeps track of all the sessions

    Unlike a lot of the other *Lists, this datastructure probably
    won't be interacted as much as with the individual Sessions
    """

    def __init__(self):
        """
        Pretty boring, just initializes all the datastructures
        """

        # Holds all the sessions
        self.sessions = {}

        # Keeps track of the next index number to assign for a session
        self.next_index = 0

        # I'm holding off on other lookup datastructures until I get
        # a better feeling about what would be useful. Ideally this would
        # keep track of keyspace that has been exhausted, but that gets complicated
        # since different hashes might have had different attacks run against them.

    def add(self, pw_cracker_mgr, session_info, compleated=False, check_duplicates=True):
        """
        Inputs:
            pw_cracker_mgr: (PWCrackerMgr) The PWCrackerMgr object that this session was created with
            I'm doing this so I don't need to remember what string I used to represent
            John the Ripper vs. Hashcat

            session_info: (Dict) This is generated by pw_cracker_mgr to contain information about the
            particular attack. They will probably be mostly the same, but I'd like to add flexability
            when adding new password crackign tools

            compleated: (Bool) If this session was finalized/completed or if it was only partially
            run.

            check_duplicates: (Bool) If duplicates should be looked for. There's a chance of false
            positives since you might have run attacks against different subsets of passwords that
            have the same format

        Returns:
            session_id: (INT) The ID of the Session. If a problem occurs, returns -1
        """
        # Look for duplicates
        if check_duplicates:
            for session_id, session in self.sessions.items():
                if pw_cracker_mgr.name != session.tool:
                    continue
                if 'mode' in session_info and session.mode != session_info['mode']:
                    continue
                elif 'mode' not in session_info and session.mode:
                    continue
                if 'hash_type' in session_info and session_info['hash_type'] != session.hash_type:
                    continue

                # Session specific options
                exact_match = True

                if 'options' not in session_info and len(session.options.keys()) > 0:
                    continue
                elif 'options' in session_info:
                    for key, value in session_info['options'].items():
                        if key in session.options and value == session.options[key]:
                            pass
                        else:
                            exact_match = False
                            break
                
                if exact_match:
                    # Update compleated if it was not set before
                    if not session.compleated:
                        session.compleated = compleated
                    return session_id 

        session_id = self.next_index
        self.next_index += 1

        self.sessions[session_id] = Session(pw_cracker_mgr, session_info, compleated)

        return session_id